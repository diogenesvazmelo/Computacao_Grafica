/// g++ -o main.cpp -lSDLmain -lSDL -lGL
/// Design: piskel.com

#include <SDL.h>
#include "SDL_opengl.h"
#include <stdio.h>
#include "cores.c"

#define LARGURA_JANELA 600
#define ALTURA_JANELA 400

#define COMPRIMENTO_INIMIGO 50
#define ALTURA_INIMIGO 50

#define VELOCIDADE_LATERAL 0.1
#define FATOR_DIVISAO_VELOCIDADE_INIMIGO 5 // A velocidade lateral do inimigo será X vezes menor que a velocidade lateral da nossa nave

#define QUANTIDADE_DE_INIMIGOS 5

float VELOCIDADE_LATERAL_INIMIGO = VELOCIDADE_LATERAL/FATOR_DIVISAO_VELOCIDADE_INIMIGO;

float espaco_entre_inimigos = (LARGURA_JANELA - (COMPRIMENTO_INIMIGO * QUANTIDADE_DE_INIMIGOS))/ (QUANTIDADE_DE_INIMIGOS + 1);


bool gEsquerda = false;
bool gDireita = false;

typedef struct
{
   float x;
   float y;
}Coordenada;

typedef struct
{
   Coordenada inicial;
   Coordenada incremento;
}Objeto2dIncremento;



void desenhaQuadradoIncremento(Coordenada primeira, Coordenada incremento, Cores cor);
void desenhaQuadradoAbs(Coordenada primeira, Coordenada ultima, Cores cor);
void desenhaLinha(Coordenada primeira, Coordenada ultima, Cores cor);
void desenhaTiro(Coordenada primeira, Coordenada incremento);

void movimentaLateralmente(SDL_Event eventos, float posicao);
void movimentaLateralmente2(SDL_Event eventos);

void movimentoInimigo(Coordenada *inimigo, Coordenada *incremento, float auxiliar_velocidade_l, int qual_inimigo);

void movimentoTiro(Coordenada *tiro);


void atira(SDL_Event eventos, Coordenada posicao, Coordenada incremento);

bool colisao(Coordenada obj1, Coordenada obj1_incremento, Coordenada obj2, Coordenada obj2_incremento);

int main(int argc, char* args[])
{

    SDL_Init(SDL_INIT_EVERYTHING);
    //glDisable(GL_BLEND); //Para Windows apenas

    //memoria
    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, 32);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16); //Usado em coisas 3D
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

    // Nome da janela
    SDL_WM_SetCaption("TP01_SDL", NULL);

    // Tamanho da janela
    SDL_SetVideoMode(LARGURA_JANELA, ALTURA_JANELA, 32, SDL_OPENGL); // 600x400. 32 é relativo a bits por pixel

    // Cor inicial
    glClearColor(1.0, 1.0, 1.0, 1.0); //preto

    // Área exibida
    glViewport(0, 0, 600, 400);

    // Sombra
    glShadeModel(GL_SMOOTH); //sombreamento

    // 2D
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity(); //desenho geometrico

    // 3D
    glDisable(GL_DEPTH_TEST);
    //-----------------------------------------------------------------

    bool executando = true;

    SDL_Event eventos;

        // Nave
        Coordenada person;
            person.x = (LARGURA_JANELA/2) - 25;
            person.y = ALTURA_JANELA - 50;
        Coordenada person_incremento;
            person_incremento.x = 50;
            person_incremento.y = 30;

        // Inimigos
        /*
        Coordenada inimigo;
            inimigo.x = (LARGURA_JANELA/2) - 25;
            inimigo.y = 50;
        Coordenada inimigo_incremento;
            inimigo_incremento.x = 30;
            inimigo_incremento.y = 30;
        */
        Objeto2dIncremento inimigo[QUANTIDADE_DE_INIMIGOS];
        if (espaco_entre_inimigos < 5) // Espaço mínimo entre inimigos
        {
            espaco_entre_inimigos = 5;
        }
        for (int i = 0, x = espaco_entre_inimigos, y = 10; i < QUANTIDADE_DE_INIMIGOS; i++, x += (COMPRIMENTO_INIMIGO + espaco_entre_inimigos))
        {
            if (x > (LARGURA_JANELA - espaco_entre_inimigos - COMPRIMENTO_INIMIGO))
            {
                y += ALTURA_INIMIGO + 30;
                x = espaco_entre_inimigos;
            }
            inimigo[i].inicial.x = x;
            inimigo[i].inicial.y = y;
            inimigo[i].incremento.x = COMPRIMENTO_INIMIGO;
            inimigo[i].incremento.y = ALTURA_INIMIGO;
        }


    /// Loop do Jogo
    while(executando)
    {
        // Eventos
        while(SDL_PollEvent(&eventos))
        {
            // Fecha com o x da janela ou com esc
            if (eventos.type == SDL_QUIT || (eventos.type == SDL_KEYUP && eventos.key.keysym.sym == SDLK_ESCAPE))
            {
                executando = false;
            }

            // Anda lateralmente
            else
            {
                movimentaLateralmente(eventos, person.x);
                desenhaTiro(person, person_incremento);
                atira(eventos, person, person_incremento);
            }
        }

        /// LÓGICA

            /// Movimento

            // Movimento lateral do personagem (nave)
            if (gEsquerda == true)
            {
                person.x -= VELOCIDADE_LATERAL; // Ajusta a velocidade lateral
            }
            else if (gDireita == true)
            {
                person.x += VELOCIDADE_LATERAL; // Ajusta a velocidade lateral
            }

            // Movimento do inimigo
            /*
            movimentoInimigo(&inimigo, &inimigo_incremento, VELOCIDADE_LATERAL_INIMIGO);
            if (inimigo.x < 0 || (inimigo.x + inimigo_incremento.x > LARGURA_JANELA))
            {
                VELOCIDADE_LATERAL_INIMIGO = -VELOCIDADE_LATERAL_INIMIGO;
                inimigo.y += VELOCIDADE_LATERAL * 100; // Inimigo desce com uma velocidade 100 superior ao movimento lateral da nave
            }

            if (colisao(inimigo, inimigo_incremento, person, person_incremento) == true)
            {
                executando = false; // Sai do jogo
            }
            */
            for (int i = 0; i < QUANTIDADE_DE_INIMIGOS; i++)
            {
                movimentoInimigo(&inimigo[i].inicial, &inimigo[i].incremento, VELOCIDADE_LATERAL_INIMIGO, i);
                if (inimigo[i].inicial.x <= ((((i + 0) * COMPRIMENTO_INIMIGO) + ((i + 0) * espaco_entre_inimigos))) || (inimigo[i].inicial.x + inimigo[i].incremento.x >= ((((i + 1) * COMPRIMENTO_INIMIGO) + ((i + 1) * espaco_entre_inimigos)) + espaco_entre_inimigos)))
                {
                    for (int j = 0; j < QUANTIDADE_DE_INIMIGOS; j++)
                    {
                        inimigo[j].inicial.y += VELOCIDADE_LATERAL * 100; // Inimigo desce com uma velocidade 100 superior ao movimento lateral da nave
                    }
                    VELOCIDADE_LATERAL_INIMIGO = -VELOCIDADE_LATERAL_INIMIGO;
                    //inimigo[i].inicial.y += VELOCIDADE_LATERAL * 100.01; 
                }

                if (colisao(inimigo[i].inicial, inimigo[i].incremento, person, person_incremento) == true)
                {
                    executando = false; // Sai do jogo
                }
            }



        /// RENDERIZAÇÃO
        glClear (GL_COLOR_BUFFER_BIT); //Limpa o buffer

        // Inicia matriz
        glPushMatrix();

        // Dimensoes da Matriz
        glOrtho(0, LARGURA_JANELA, ALTURA_JANELA, 0, -1, 1);

        // Cor
            // Opções:
            // glColor3d (1 ou 0)
            // glColor3f (decimais)
            // glColor3ub (R, G, B) - 0 até 255 cada um
            // glColor4ub (R, G, B, A) - 0 até 255 cada um
            //glColor4ub (255, 0, 0, 255); // vermelho máximo

        // Inicia desenho

        for (int i = 0; i < QUANTIDADE_DE_INIMIGOS; i++)
        {
            desenhaQuadradoIncremento(inimigo[i].inicial, inimigo[i].incremento, Azul());
        }

        desenhaQuadradoIncremento(person, person_incremento, Vermelho());

        // Fecha matriz
        glPopMatrix();

        /// Animação
        SDL_GL_SwapBuffers();
    }

    ///-----------------------------------------------------------





    // ------------------------------------------------------------------


    glDisable(GL_BLEND); //Para Windows apenas

    SDL_Quit();

    return 0;
}

void desenhaQuadradoAbs(Coordenada primeira, Coordenada ultima, Cores cor)
{
    glColor3f(cor.cor1, cor.cor2, cor.cor3);
    // Desenha um polígono por seus vértices

    glBegin(GL_TRIANGLE_FAN);
        // NOVIDADE: antes os valores eram -0.5, 0.5
        glVertex3f(primeira.x, primeira.y, 0.0);
        glVertex3f(ultima.x, primeira.y, 0.0);
        glVertex3f(ultima.x, ultima.y, 0.0);
        glVertex3f(primeira.x, ultima.y, 0.0);
    glEnd();
}

void desenhaQuadradoIncremento(Coordenada primeira, Coordenada incremento, Cores cor)
{
    glColor3f(cor.cor1, cor.cor2, cor.cor3);
    // Desenha um polígono por seus vértices

    glBegin(GL_TRIANGLE_FAN);
        // NOVIDADE: antes os valores eram -0.5, 0.5
        glVertex3f(primeira.x, primeira.y, 0.0);
        glVertex3f(primeira.x + incremento.x, primeira.y, 0.0);
        glVertex3f(primeira.x + incremento.x, primeira.y + incremento.y, 0.0);
        glVertex3f(primeira.x, primeira.y + incremento.y, 0.0);
    glEnd();
}

void desenhaTiro(Coordenada primeira, Coordenada incremento)
{
    Cores cor = Amarelo();
    glColor3f(cor.cor1, cor.cor2, cor.cor3);

    // Desenha um polígono por seus vértices

    glBegin(GL_TRIANGLE_FAN);
        // NOVIDADE: antes os valores eram -0.5, 0.5
        glVertex3f(primeira.x, primeira.y, 0.0);
        glVertex3f(primeira.x + incremento.x, primeira.y, 0.0);
        glVertex3f(primeira.x + incremento.x, primeira.y + incremento.y, 0.0);
        glVertex3f(primeira.x, primeira.y + incremento.y, 0.0);
    glEnd();
}


void desenhaLinha(Coordenada primeira, Coordenada ultima, Cores cor)
{
    glColor3f(cor.cor1, cor.cor2, cor.cor3);
    // Desenha um polígono por seus vértices

    glBegin(GL_LINES); // GL_POINTS, GL_LINES, GL_LINES_LOOP, GL_QUADS, GL_TRIANGLES, GL_POLIGOM
        glVertex3f(primeira.x, primeira.y, 0.0);
        glVertex3f(ultima.x, ultima.y, 0.0);
    glEnd();
}

void movimentaLateralmente(SDL_Event eventos, float posicao)
{
    //if (posicao <= 0)
    {
        //gEsquerda == false;
    }
    //else if (posicao >= LARGURA_JANELA)
    {
        //gDireita == false;
    }
    //else
    {
            if (eventos.type == SDL_KEYDOWN)
            {
                if (eventos.key.keysym.sym == SDLK_LEFT && eventos.key.keysym.sym == SDLK_RIGHT)
                {
                    gEsquerda = false;
                    gDireita = false;
                }
                else if (eventos.key.keysym.sym == SDLK_LEFT)
                {
                    gEsquerda = true;
                }
                else if (eventos.key.keysym.sym == SDLK_RIGHT)
                {
                    gDireita = true;
                }
            }
            else if (eventos.type == SDL_KEYUP)
            {
                if (eventos.key.keysym.sym == SDLK_LEFT)
                {
                    gEsquerda = false;
                }
                if (eventos.key.keysym.sym == SDLK_RIGHT)
                {
                    gDireita = false;
                }
            }
    }
}

void atira(SDL_Event eventos, Coordenada posicao, Coordenada incremento)
{
    if (eventos.type == SDL_KEYDOWN)
    {
        if (eventos.key.keysym.sym == SDLK_SPACE)
        {
            posicao.y += incremento.y + 5;
            desenhaTiro(posicao, incremento);
        }
    }
}

void movimentaLateralmente2(SDL_Event eventos)
{
            if (eventos.type == SDL_KEYDOWN)
            {
                //if (eventos.key.keysym.sym == SDLK_LEFT && eventos.key.keysym.sym == SDLK_RIGHT)
                //{
                //    gEsquerda = false;
                //    gDireita = false;
                //}
                if (eventos.key.keysym.sym == SDLK_LEFT)
                {
                    gEsquerda = true;
                }
                else if (eventos.key.keysym.sym == SDLK_RIGHT)
                {
                    gDireita = true;
                }
            }
            else if (eventos.type == SDL_KEYUP)
            {
                if (eventos.key.keysym.sym == SDLK_LEFT)
                {
                    gEsquerda = false;
                }
                if (eventos.key.keysym.sym == SDLK_RIGHT)
                {
                    gDireita = false;
                }
            }
}

void movimentoTiro(Coordenada *tiro)
{
    tiro->y += (VELOCIDADE_LATERAL * 10);
}

void movimentoInimigo(Coordenada *inimigo, Coordenada *incremento, float auxiliar_velocidade_l, int qual_inimigo)
{
    inimigo->x += auxiliar_velocidade_l;
    //inimigo->y += auxiliar_velocidade_l;

    if (inimigo->x <= ((((qual_inimigo + 0) * COMPRIMENTO_INIMIGO) + ((qual_inimigo + 0) * espaco_entre_inimigos))) || (inimigo->x + incremento->x) >= ((((qual_inimigo + 1) * COMPRIMENTO_INIMIGO) + ((qual_inimigo + 1) * espaco_entre_inimigos)) + espaco_entre_inimigos))
    {
        //inimigo->y += auxiliar_velocidade_l;
    }
}

bool colisao(Coordenada obj1, Coordenada obj1_incremento, Coordenada obj2, Coordenada obj2_incremento)
{
    if (obj1.y + obj1_incremento.y < obj2.y)
    {
        return false;
    }
    else if (obj1.y > obj2.y + obj2_incremento.y)
    {
        return false;
    }
    else if (obj1.x + obj1_incremento.x < obj2.x)
    {
        return false;
    }
    else if (obj1.x > obj2.x + obj2_incremento.x)
    {
        return false;
    }
    else
    {
        return true;
    }
}
